<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ThorVG Canvas Kit - Scene Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        #canvas {
            border: 1px solid #333;
            background: white;
            margin: 20px 0;
        }
        .controls {
            margin: 10px 0;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        .info {
            background: #fff;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>ThorVG Canvas Kit - Scene Example</h1>

    <div class="info">
        <h3>Scene API Features:</h3>
        <ul>
            <li>Hierarchical composition - group multiple paints into a scene</li>
            <li>Transform groups - apply transformations to entire scene</li>
            <li>Nested scenes - scenes can contain other scenes</li>
            <li>Scene-level opacity and blending</li>
        </ul>
    </div>

    <div class="controls">
        <label>Backend:
            <select id="backend">
                <option value="sw">Software</option>
                <option value="gl">WebGL</option>
                <option value="wg">WebGPU</option>
            </select>
        </label>
        <button onclick="init()">Initialize</button>
        <button onclick="drawScene()">Draw Scene</button>
        <button onclick="clearCanvas()">Clear</button>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <div class="info">
        <h3>Status:</h3>
        <pre id="log"></pre>
    </div>

    <script type="module">
        import ThorVGModule from '../build_wasm_canvaskit/src/bindings/wasm/thorvg-canvaskit.js';

        let TVG;
        let engine;
        let canvasPtr = 0;

        function log(msg) {
            const logEl = document.getElementById('log');
            logEl.textContent += msg + '\n';
            console.log(msg);
        }

        async function loadModule() {
            log('Loading ThorVG Canvas Kit module...');
            TVG = await ThorVGModule();
            log('Module loaded successfully!');
        }

        async function initModule(renderer) {
            log('Initializing Canvas Kit...');

            if (renderer !== 'wg') {
                return;
            }

            let status;
            let attempts = 0;
            do {
                status = TVG.init();
                if (status === 2) {
                    log(`  Waiting for initialization... (attempt ${++attempts})`);
                    await new Promise(r => setTimeout(r, 100));
                }
            } while (status === 2 && attempts < 50);

            if (status !== 0) {
                log('ERROR: Canvas Kit initialization failed!');
                return;
            }
            log('Canvas Kit initialized successfully!');
        }

        function applyRendererFromQuery() {
            const params = new URLSearchParams(window.location.search);
            const renderer = params.get('renderer');
            if (!renderer) return;

            const backendSelect = document.getElementById('backend');
            if (['sw', 'gl', 'wg'].includes(renderer)) {
                backendSelect.value = renderer;
            }
        }

        function setupRendererChangeHandler() {
            const backendSelect = document.getElementById('backend');
            backendSelect.addEventListener('change', () => {
                const renderer = backendSelect.value;
                const url = new URL(window.location.href);
                url.searchParams.set('renderer', renderer);
                window.location.href = url.toString();
            });
        }

        window.init = async function() {
            if (!TVG) {
                await loadModule();
            }

            const backend = document.getElementById('backend').value;
            log(`Initializing with ${backend} backend...`);

            await initModule(backend);

            engine = new TVG.ThorVGEngine();
            const selector = '#canvas';
            canvasPtr = engine.createCanvas(backend, selector, 800, 600);

            if (canvasPtr === 0) {
                log('ERROR: Failed to create canvas!');
                return;
            }

            log(`Canvas created successfully! (ptr: ${canvasPtr})`);
            log('Ready to draw!');
        };

        window.drawScene = function() {
            if (canvasPtr === 0) {
                log('ERROR: Canvas not initialized. Click Initialize first!');
                return;
            }

            log('Drawing scene hierarchy...');

            // Create main scene
            const mainScene = TVG._tvg_scene_new();
            log('Created main scene');

            // Create a sub-scene with two circles
            const subScene1 = TVG._tvg_scene_new();

            // Circle 1 in sub-scene
            const circle1 = TVG._tvg_shape_new();
            TVG._tvg_shape_append_circle(circle1, 0, 0, 50, 50, 1);
            TVG._tvg_shape_set_fill_color(circle1, 255, 100, 100, 255);
            TVG._tvg_paint_translate(circle1, 0, 0);
            TVG._tvg_scene_push(subScene1, circle1);

            // Circle 2 in sub-scene
            const circle2 = TVG._tvg_shape_new();
            TVG._tvg_shape_append_circle(circle2, 0, 0, 50, 50, 1);
            TVG._tvg_shape_set_fill_color(circle2, 100, 255, 100, 255);
            TVG._tvg_paint_translate(circle2, 80, 0);
            TVG._tvg_scene_push(subScene1, circle2);

            // Transform and add sub-scene to main scene
            TVG._tvg_paint_translate(subScene1, 150, 150);
            TVG._tvg_scene_push(mainScene, subScene1);
            log('Added sub-scene 1 with 2 circles');

            // Create another sub-scene with rectangles
            const subScene2 = TVG._tvg_scene_new();

            // Rectangle 1 in sub-scene
            const rect1 = TVG._tvg_shape_new();
            TVG._tvg_shape_append_rect(rect1, 0, 0, 80, 60, 10, 10, 1);
            TVG._tvg_shape_set_fill_color(rect1, 100, 100, 255, 255);
            TVG._tvg_paint_translate(rect1, 0, 0);
            TVG._tvg_scene_push(subScene2, rect1);

            // Rectangle 2 in sub-scene
            const rect2 = TVG._tvg_shape_new();
            TVG._tvg_shape_append_rect(rect2, 0, 0, 60, 80, 10, 10, 1);
            TVG._tvg_shape_set_fill_color(rect2, 255, 255, 100, 255);
            TVG._tvg_paint_translate(rect2, 100, 0);
            TVG._tvg_scene_push(subScene2, rect2);

            // Transform and add second sub-scene to main scene
            TVG._tvg_paint_translate(subScene2, 400, 200);
            TVG._tvg_paint_rotate(subScene2, 15); // Rotate the entire sub-scene
            TVG._tvg_scene_push(mainScene, subScene2);
            log('Added sub-scene 2 with 2 rectangles (rotated)');

            // Create a nested scene hierarchy
            const nestedScene = TVG._tvg_scene_new();

            for (let i = 0; i < 5; i++) {
                const star = TVG._tvg_shape_new();
                // Simple star shape (triangle)
                TVG._tvg_shape_move_to(star, 0, -20);
                TVG._tvg_shape_line_to(star, 15, 20);
                TVG._tvg_shape_line_to(star, -15, 20);
                TVG._tvg_shape_close(star);

                const hue = i * 70;
                TVG._tvg_shape_set_fill_color(star,
                    Math.floor(255 * Math.abs(Math.sin(hue * Math.PI / 180))),
                    Math.floor(255 * Math.abs(Math.sin((hue + 120) * Math.PI / 180))),
                    Math.floor(255 * Math.abs(Math.sin((hue + 240) * Math.PI / 180))),
                    255
                );
                TVG._tvg_paint_translate(star, i * 40, 0);
                TVG._tvg_scene_push(nestedScene, star);
            }

            TVG._tvg_paint_translate(nestedScene, 250, 400);
            TVG._tvg_paint_set_opacity(nestedScene, 200); // Semi-transparent scene
            TVG._tvg_scene_push(mainScene, nestedScene);
            log('Added nested scene with 5 stars (semi-transparent)');

            // Add the main scene to canvas
            TVG._tvg_canvas_push(canvasPtr, mainScene);

            // Render
            TVG._tvg_canvas_draw(canvasPtr, 1);
            TVG._tvg_canvas_sync(canvasPtr);

            log('Scene rendering complete!');
            log('Hierarchy: MainScene -> [SubScene1, SubScene2, NestedScene]');

            // For SW backend, copy buffer to canvas
            const backend = document.getElementById('backend').value;
            if (backend === 'sw') {
                const buffer = engine.render();
                const size = engine.size();
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                const imageData = new ImageData(
                    new Uint8ClampedArray(buffer),
                    size.width,
                    size.height
                );
                ctx.putImageData(imageData, 0, 0);
                log('Buffer copied to canvas!');
            }
        };

        window.clearCanvas = function() {
            if (!engine) {
                log('ERROR: Engine not initialized!');
                return;
            }

            engine.clear();
            TVG._tvg_canvas_draw(canvasPtr, 1);
            TVG._tvg_canvas_sync(canvasPtr);

            const backend = document.getElementById('backend').value;
            if (backend === 'sw') {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            log('Canvas cleared!');
        };

        applyRendererFromQuery();
        setupRendererChangeHandler();
        loadModule();
    </script>
</body>
</html>
