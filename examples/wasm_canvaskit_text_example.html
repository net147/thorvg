<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ThorVG Canvas Kit - Text Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        #canvas {
            border: 1px solid #333;
            background: white;
            margin: 20px 0;
        }
        .controls {
            margin: 10px 0;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        .info {
            background: #fff;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        input[type="file"] {
            margin: 5px 0;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        .control-group label {
            min-width: 100px;
        }
        input[type="text"],
        input[type="number"],
        textarea {
            padding: 5px;
            flex: 1;
        }
        textarea {
            min-height: 60px;
            font-family: inherit;
        }
        input[type="range"] {
            width: 200px;
        }
        .color-preview {
            width: 30px;
            height: 30px;
            border: 1px solid #333;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>ThorVG Canvas Kit - Text Example</h1>

    <div class="info">
        <h3>Text API Features:</h3>
        <ul>
            <li>Custom font loading (TTF, OTF)</li>
            <li>Font size and color control</li>
            <li>Text alignment (left, center, right, top, middle, bottom)</li>
            <li>Text layout and wrapping (word, character, ellipsis)</li>
            <li>Italic style with shear control</li>
            <li>Text outline (stroke)</li>
            <li>Gradient fill support</li>
        </ul>
    </div>

    <div class="controls">
        <label>Backend:
            <select id="backend">
                <option value="sw">Software</option>
                <option value="gl">WebGL</option>
                <option value="wg">WebGPU</option>
            </select>
        </label>
        <button onclick="init()">Initialize</button>
        <br>
        <label>Load Custom Font (Optional):
            <input type="file" id="fontInput" accept=".ttf,.otf" onchange="loadFont(event)">
        </label>
        <span style="color: #666; font-size: 0.9em;">Default font is pre-loaded</span>
    </div>

    <div class="control-group">
        <label>Text:</label>
        <textarea id="textInput" placeholder="Enter text here...">Hello ThorVG!\nì•ˆë…•í•˜ì„¸ìš” ðŸŽ¨</textarea>
    </div>

    <div class="control-group">
        <label>Font Size:</label>
        <input type="range" id="fontSize" min="12" max="120" value="48" oninput="updateFontSize(this.value)">
        <span id="fontSizeLabel">48</span>
    </div>

    <div class="control-group">
        <label>Text Color:</label>
        <input type="color" id="textColor" value="#ff0000" onchange="updateColor()">
    </div>

    <div class="control-group">
        <label>H-Align:</label>
        <select id="hAlign" onchange="updateAlign()">
            <option value="0">Left</option>
            <option value="0.5" selected>Center</option>
            <option value="1">Right</option>
        </select>
    </div>

    <div class="control-group">
        <label>V-Align:</label>
        <select id="vAlign" onchange="updateAlign()">
            <option value="0">Top</option>
            <option value="0.5" selected>Middle</option>
            <option value="1">Bottom</option>
        </select>
    </div>

    <div class="control-group">
        <label>Italic Shear:</label>
        <input type="range" id="italic" min="0" max="0.5" step="0.01" value="0" oninput="updateItalic(this.value)">
        <span id="italicLabel">0.00</span>
    </div>

    <div class="control-group">
        <label>Outline Width:</label>
        <input type="range" id="outlineWidth" min="0" max="10" step="0.5" value="0" oninput="updateOutline()">
        <span id="outlineWidthLabel">0</span>
    </div>

    <div class="control-group">
        <label>Outline Color:</label>
        <input type="color" id="outlineColor" value="#000000" onchange="updateOutline()">
    </div>

    <div class="control-group">
        <label>Wrap Mode:</label>
        <select id="wrapMode" onchange="updateWrapMode()">
            <option value="0" selected>None</option>
            <option value="1">Character</option>
            <option value="2">Word</option>
            <option value="3">Smart</option>
            <option value="4">Ellipsis</option>
        </select>
    </div>

    <div class="control-group">
        <label>Layout Width:</label>
        <input type="number" id="layoutWidth" min="0" max="800" value="600" onchange="updateLayout()">
    </div>

    <div class="controls">
        <button onclick="drawText()">Draw Text</button>
        <button onclick="clearCanvas()">Clear</button>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <div class="info">
        <h3>Status:</h3>
        <pre id="log"></pre>
    </div>

    <script type="module">
        import ThorVGModule from '../build_wasm_canvaskit/src/bindings/wasm/thorvg-canvaskit.js';

        let TVG;
        let engine;
        let canvasPtr = 0;
        let currentText = 0;
        let fontName = null;
        let fontLoaded = false;

        function log(msg) {
            const logEl = document.getElementById('log');
            logEl.textContent += msg + '\n';
            console.log(msg);
        }

        async function loadModule() {
            log('Loading ThorVG Canvas Kit module...');
            TVG = await ThorVGModule();
            log('Module loaded successfully!');
        }

        async function initModule(renderer) {
            log('Initializing Canvas Kit...');

            if (renderer !== 'wg') {
                return;
            }

            let status;
            let attempts = 0;
            do {
                status = TVG.init();
                if (status === 2) {
                    log(`  Waiting for initialization... (attempt ${++attempts})`);
                    await new Promise(r => setTimeout(r, 100));
                }
            } while (status === 2 && attempts < 50);

            if (status !== 0) {
                log('ERROR: Canvas Kit initialization failed!');
                return;
            }
            log('Canvas Kit initialized successfully!');
        }

        function applyRendererFromQuery() {
            const params = new URLSearchParams(window.location.search);
            const renderer = params.get('renderer');
            if (!renderer) return;

            const backendSelect = document.getElementById('backend');
            if (['sw', 'gl', 'wg'].includes(renderer)) {
                backendSelect.value = renderer;
            }
        }

        function setupRendererChangeHandler() {
            const backendSelect = document.getElementById('backend');
            backendSelect.addEventListener('change', () => {
                const renderer = backendSelect.value;
                const url = new URL(window.location.href);
                url.searchParams.set('renderer', renderer);
                window.location.href = url.toString();
            });
        }

        window.init = async function() {
            if (!TVG) {
                await loadModule();
            }

            const backend = document.getElementById('backend').value;
            log(`Initializing with ${backend} backend...`);

            await initModule(backend);

            engine = new TVG.ThorVGEngine();
            const selector = '#canvas';
            canvasPtr = engine.createCanvas(backend, selector, 800, 600);

            if (canvasPtr === 0) {
                log('ERROR: Failed to create canvas!');
                return;
            }

            log(`Canvas created successfully! (ptr: ${canvasPtr})`);
            log('Ready to load font and draw text!');
        };

        window.loadFont = async function(event) {
            const file = event.target.files[0];
            if (!file) return;

            log(`Loading font: ${file.name}...`);

            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);

            // Allocate memory for font data
            const fontPtr = TVG._malloc(uint8Array.length);
            TVG.HEAPU8.set(uint8Array, fontPtr);

            // Extract font name (without extension)
            fontName = file.name.replace(/\.[^/.]+$/, '');

            // Load font data (copy=true so we can free our buffer)
            const namePtr = TVG._malloc(fontName.length + 1);
            TVG.HEAPU8.set(new TextEncoder().encode(fontName), namePtr);
            TVG.HEAPU8[namePtr + fontName.length] = 0;

            const ext = file.name.split('.').pop().toLowerCase();
            const mimePtr = TVG._malloc(ext.length + 1);
            TVG.HEAPU8.set(new TextEncoder().encode(ext), mimePtr);
            TVG.HEAPU8[mimePtr + ext.length] = 0;

            const result = TVG._tvg_font_load_data(namePtr, fontPtr, uint8Array.length, mimePtr, true);

            TVG._free(fontPtr);
            TVG._free(namePtr);
            TVG._free(mimePtr);

            if (result === 0) {
                fontLoaded = true;
                log(`Font "${fontName}" loaded successfully!`);
            } else {
                log(`ERROR: Failed to load font (error code: ${result})`);
                fontName = null;
            }
        };

        window.drawText = function() {
            if (canvasPtr === 0) {
                log('ERROR: Canvas not initialized. Click Initialize first!');
                return;
            }

            // Clear previous text
            if (currentText) {
                engine.clear();
            }

            const textContent = document.getElementById('textInput').value;
            if (!textContent) {
                log('ERROR: No text entered!');
                return;
            }

            log('Drawing text...');

            // Create text object
            currentText = TVG._tvg_text_new();
            if (!currentText) {
                log('ERROR: Failed to create text object!');
                return;
            }

            // Set font (use custom font if loaded, otherwise use default)
            const useFontName = fontLoaded && fontName ? fontName : "default";
            const fontNamePtr = TVG._malloc(useFontName.length + 1);
            TVG.HEAPU8.set(new TextEncoder().encode(useFontName), fontNamePtr);
            TVG.HEAPU8[fontNamePtr + useFontName.length] = 0;
            TVG._tvg_text_set_font(currentText, fontNamePtr);
            TVG._free(fontNamePtr);

            // Set font size
            const fontSize = parseFloat(document.getElementById('fontSize').value);
            TVG._tvg_text_set_size(currentText, fontSize);

            // Set text content (UTF-8)
            const textBytes = new TextEncoder().encode(textContent);
            const textPtr = TVG._malloc(textBytes.length + 1);
            TVG.HEAPU8.set(textBytes, textPtr);
            TVG.HEAPU8[textPtr + textBytes.length] = 0;
            TVG._tvg_text_set_text(currentText, textPtr);
            TVG._free(textPtr);

            // Set color
            const color = document.getElementById('textColor').value;
            const r = parseInt(color.substr(1, 2), 16);
            const g = parseInt(color.substr(3, 2), 16);
            const b = parseInt(color.substr(5, 2), 16);
            TVG._tvg_text_set_color(currentText, r, g, b);

            // Set alignment
            const hAlign = parseFloat(document.getElementById('hAlign').value);
            const vAlign = parseFloat(document.getElementById('vAlign').value);
            TVG._tvg_text_align(currentText, hAlign, vAlign);

            // Set layout (for wrapping)
            const layoutWidth = parseFloat(document.getElementById('layoutWidth').value);
            TVG._tvg_text_layout(currentText, layoutWidth, 0);

            // Set wrap mode
            const wrapMode = parseInt(document.getElementById('wrapMode').value);
            TVG._tvg_text_wrap_mode(currentText, wrapMode);

            // Set italic
            const italic = parseFloat(document.getElementById('italic').value);
            if (italic > 0) {
                TVG._tvg_text_set_italic(currentText, italic);
            }

            // Set outline
            const outlineWidth = parseFloat(document.getElementById('outlineWidth').value);
            if (outlineWidth > 0) {
                const outlineColor = document.getElementById('outlineColor').value;
                const or = parseInt(outlineColor.substr(1, 2), 16);
                const og = parseInt(outlineColor.substr(3, 2), 16);
                const ob = parseInt(outlineColor.substr(5, 2), 16);
                TVG._tvg_text_set_outline(currentText, outlineWidth, or, og, ob);
            }

            // Position text at center of canvas
            TVG._tvg_paint_translate(currentText, 400, 300);

            // Add to canvas
            TVG._tvg_canvas_push(canvasPtr, currentText);

            // Render
            TVG._tvg_canvas_draw(canvasPtr, 1);
            TVG._tvg_canvas_sync(canvasPtr);

            log('Text rendering complete!');

            // For SW backend, copy buffer to canvas
            const backend = document.getElementById('backend').value;
            if (backend === 'sw') {
                const buffer = engine.render();
                const size = engine.size();
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                const imageData = new ImageData(
                    new Uint8ClampedArray(buffer),
                    size.width,
                    size.height
                );
                ctx.putImageData(imageData, 0, 0);
                log('Buffer copied to canvas!');
            }
        };

        window.updateFontSize = function(value) {
            document.getElementById('fontSizeLabel').textContent = value;
        };

        window.updateColor = function() {
            if (currentText) drawText();
        };

        window.updateAlign = function() {
            if (currentText) drawText();
        };

        window.updateItalic = function(value) {
            document.getElementById('italicLabel').textContent = parseFloat(value).toFixed(2);
            if (currentText) drawText();
        };

        window.updateOutline = function() {
            const width = document.getElementById('outlineWidth').value;
            document.getElementById('outlineWidthLabel').textContent = width;
            if (currentText) drawText();
        };

        window.updateWrapMode = function() {
            if (currentText) drawText();
        };

        window.updateLayout = function() {
            if (currentText) drawText();
        };

        window.clearCanvas = function() {
            if (!engine) {
                log('ERROR: Engine not initialized!');
                return;
            }

            engine.clear();
            TVG._tvg_canvas_draw(canvasPtr, 1);
            TVG._tvg_canvas_sync(canvasPtr);

            const backend = document.getElementById('backend').value;
            if (backend === 'sw') {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            currentText = 0;
            log('Canvas cleared!');
        };

        applyRendererFromQuery();
        setupRendererChangeHandler();
        loadModule();
    </script>
</body>
</html>
