<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ThorVG Canvas Kit - Picture Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        #canvas {
            border: 1px solid #333;
            background: white;
            margin: 20px 0;
        }
        .controls {
            margin: 10px 0;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        .info {
            background: #fff;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        input[type="file"] {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <h1>ThorVG Canvas Kit - Picture Example</h1>

    <div class="info">
        <h3>Picture API Features:</h3>
        <ul>
            <li>Load SVG, PNG, JPG, WebP, and Lottie files</li>
            <li>Resize and scale pictures</li>
            <li>Transform pictures (translate, rotate, scale)</li>
            <li>Picture opacity and blending</li>
            <li>Load from file path or raw data</li>
        </ul>
    </div>

    <div class="controls">
        <label>Backend:
            <select id="backend">
                <option value="sw">Software</option>
                <option value="gl">WebGL</option>
                <option value="wg">WebGPU</option>
            </select>
        </label>
        <button onclick="init()">Initialize</button>
        <button onclick="drawPicture()">Draw SVG Programmatically</button>
        <button onclick="clearCanvas()">Clear</button>
        <br>
        <label>Load Image File:
            <input type="file" id="fileInput" accept="image/*,.svg" onchange="loadImageFile(event)">
        </label>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <div class="info">
        <h3>Status:</h3>
        <pre id="log"></pre>
    </div>

    <script type="module">
        import ThorVGModule from '../build_wasm_canvaskit/src/bindings/wasm/thorvg-canvaskit.js';

        let TVG;
        let engine;
        let canvasPtr = 0;

        function log(msg) {
            const logEl = document.getElementById('log');
            logEl.textContent += msg + '\n';
            console.log(msg);
        }

        async function loadModule() {
            log('Loading ThorVG Canvas Kit module...');
            TVG = await ThorVGModule();
            log('Module loaded successfully!');
        }

        async function initModule(renderer) {
            log('Initializing Canvas Kit...');

            if (renderer !== 'wg') {
                return;
            }

            let status;
            let attempts = 0;
            do {
                status = TVG.init();
                if (status === 2) {
                    log(`  Waiting for initialization... (attempt ${++attempts})`);
                    await new Promise(r => setTimeout(r, 100));
                }
            } while (status === 2 && attempts < 50);

            if (status !== 0) {
                log('ERROR: Canvas Kit initialization failed!');
                return;
            }
            log('Canvas Kit initialized successfully!');
        }

        function applyRendererFromQuery() {
            const params = new URLSearchParams(window.location.search);
            const renderer = params.get('renderer');
            if (!renderer) return;

            const backendSelect = document.getElementById('backend');
            if (['sw', 'gl', 'wg'].includes(renderer)) {
                backendSelect.value = renderer;
            }
        }

        function setupRendererChangeHandler() {
            const backendSelect = document.getElementById('backend');
            backendSelect.addEventListener('change', () => {
                const renderer = backendSelect.value;
                const url = new URL(window.location.href);
                url.searchParams.set('renderer', renderer);
                window.location.href = url.toString();
            });
        }

        window.init = async function() {
            if (!TVG) {
                await loadModule();
            }

            const backend = document.getElementById('backend').value;
            log(`Initializing with ${backend} backend...`);

            await initModule(backend);

            engine = new TVG.ThorVGEngine();
            const selector = '#canvas';
            canvasPtr = engine.createCanvas(backend, selector, 800, 600);

            if (canvasPtr === 0) {
                log('ERROR: Failed to create canvas!');
                return;
            }

            log(`Canvas created successfully! (ptr: ${canvasPtr})`);
            log('Ready to draw!');
        };

        window.drawPicture = function() {
            if (canvasPtr === 0) {
                log('ERROR: Canvas not initialized. Click Initialize first!');
                return;
            }

            log('Drawing SVG pictures programmatically...');

            // Create a simple SVG programmatically
            const svgData = `
                <svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="100" cy="100" r="80" fill="none" stroke="#4CAF50" stroke-width="8"/>
                    <path d="M 60 100 L 90 130 L 140 70" fill="none" stroke="#4CAF50" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            `;

            // Picture 1: Original size
            {
                const picture = TVG._tvg_picture_new();
                const dataPtr = TVG._malloc(svgData.length + 1);
                TVG.HEAPU8.set(new TextEncoder().encode(svgData), dataPtr);
                TVG.HEAPU8[dataPtr + svgData.length] = 0;

                const result = TVG._tvg_picture_load_data(picture, dataPtr, svgData.length, 'svg', '', 0);
                TVG._free(dataPtr);

                if (result === 0) { // Success
                    TVG._tvg_paint_translate(picture, 50, 50);
                    TVG._tvg_canvas_push(canvasPtr, picture);
                    log('1. SVG check mark (original size) at (50, 50)');
                } else {
                    log('ERROR: Failed to load SVG data');
                    TVG._tvg_paint_rel(picture);
                }
            }

            // Picture 2: Scaled version
            {
                const picture = TVG._tvg_picture_new();
                const dataPtr = TVG._malloc(svgData.length + 1);
                TVG.HEAPU8.set(new TextEncoder().encode(svgData), dataPtr);
                TVG.HEAPU8[dataPtr + svgData.length] = 0;

                const result = TVG._tvg_picture_load_data(picture, dataPtr, svgData.length, 'svg', '', 0);
                TVG._free(dataPtr);

                if (result === 0) {
                    TVG._tvg_picture_set_size(picture, 100, 100); // Scale to 100x100
                    TVG._tvg_paint_translate(picture, 300, 50);
                    TVG._tvg_canvas_push(canvasPtr, picture);
                    log('2. SVG check mark (scaled 100x100) at (300, 50)');
                } else {
                    log('ERROR: Failed to load SVG data');
                    TVG._tvg_paint_rel(picture);
                }
            }

            // Picture 3: Rotated and scaled
            {
                const picture = TVG._tvg_picture_new();
                const dataPtr = TVG._malloc(svgData.length + 1);
                TVG.HEAPU8.set(new TextEncoder().encode(svgData), dataPtr);
                TVG.HEAPU8[dataPtr + svgData.length] = 0;

                const result = TVG._tvg_picture_load_data(picture, dataPtr, svgData.length, 'svg', '', 0);
                TVG._free(dataPtr);

                if (result === 0) {
                    TVG._tvg_picture_set_size(picture, 150, 150);
                    TVG._tvg_paint_translate(picture, 550, 50);
                    TVG._tvg_paint_rotate(picture, 45); // Rotate 45 degrees
                    TVG._tvg_canvas_push(canvasPtr, picture);
                    log('3. SVG check mark (scaled 150x150, rotated 45°) at (550, 50)');
                } else {
                    log('ERROR: Failed to load SVG data');
                    TVG._tvg_paint_rel(picture);
                }
            }

            // Picture 4: Semi-transparent
            {
                const picture = TVG._tvg_picture_new();
                const dataPtr = TVG._malloc(svgData.length + 1);
                TVG.HEAPU8.set(new TextEncoder().encode(svgData), dataPtr);
                TVG.HEAPU8[dataPtr + svgData.length] = 0;

                const result = TVG._tvg_picture_load_data(picture, dataPtr, svgData.length, 'svg', '', 0);
                TVG._free(dataPtr);

                if (result === 0) {
                    TVG._tvg_picture_set_size(picture, 120, 120);
                    TVG._tvg_paint_translate(picture, 50, 300);
                    TVG._tvg_paint_set_opacity(picture, 128); // 50% opacity
                    TVG._tvg_canvas_push(canvasPtr, picture);
                    log('4. SVG check mark (120x120, 50% opacity) at (50, 300)');
                } else {
                    log('ERROR: Failed to load SVG data');
                    TVG._tvg_paint_rel(picture);
                }
            }

            // Create a more complex SVG
            const complexSvg = `
                <svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:rgb(255,255,0);stop-opacity:1" />
                            <stop offset="100%" style="stop-color:rgb(255,0,0);stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <rect x="20" y="20" width="160" height="160" rx="20" fill="url(#grad1)"/>
                    <text x="100" y="110" font-size="40" text-anchor="middle" fill="white">SVG</text>
                </svg>
            `;

            // Picture 5: Complex SVG
            {
                const picture = TVG._tvg_picture_new();
                const dataPtr = TVG._malloc(complexSvg.length + 1);
                TVG.HEAPU8.set(new TextEncoder().encode(complexSvg), dataPtr);
                TVG.HEAPU8[dataPtr + complexSvg.length] = 0;

                const result = TVG._tvg_picture_load_data(picture, dataPtr, complexSvg.length, 'svg', '', 0);
                TVG._free(dataPtr);

                if (result === 0) {
                    TVG._tvg_picture_set_size(picture, 180, 180);
                    TVG._tvg_paint_translate(picture, 300, 280);
                    TVG._tvg_canvas_push(canvasPtr, picture);
                    log('5. Complex SVG with gradient (180x180) at (300, 280)');
                } else {
                    log('ERROR: Failed to load complex SVG');
                    TVG._tvg_paint_rel(picture);
                }
            }

            // Render
            TVG._tvg_canvas_draw(canvasPtr, 1);
            TVG._tvg_canvas_sync(canvasPtr);

            log('Picture rendering complete!');

            // For SW backend, copy buffer to canvas
            const backend = document.getElementById('backend').value;
            if (backend === 'sw') {
                const buffer = engine.render();
                const size = engine.size();
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                const imageData = new ImageData(
                    new Uint8ClampedArray(buffer),
                    size.width,
                    size.height
                );
                ctx.putImageData(imageData, 0, 0);
                log('Buffer copied to canvas!');
            }
        };

        window.loadImageFile = async function(event) {
            if (canvasPtr === 0) {
                log('ERROR: Canvas not initialized. Click Initialize first!');
                return;
            }

            const file = event.target.files[0];
            if (!file) return;

            log(`Loading file: ${file.name} (${file.type})`);

            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);

            // Allocate memory in WASM
            const dataPtr = TVG._malloc(uint8Array.length);
            TVG.HEAPU8.set(uint8Array, dataPtr);

            // Determine file extension
            const ext = file.name.split('.').pop().toLowerCase();
            let mimeType = ext;
            if (ext === 'jpg' || ext === 'jpeg') mimeType = 'jpg';
            else if (ext === 'svg') mimeType = 'svg';

            // Create picture and load data
            const picture = TVG._tvg_picture_new();
            const result = TVG._tvg_picture_load_data(picture, dataPtr, uint8Array.length, mimeType, '', 0);
            TVG._free(dataPtr);

            if (result === 0) {
                // Clear canvas first
                engine.clear();

                // Fit the picture to canvas (max 600x500)
                const sizePtr = TVG._malloc(8); // 2 floats
                TVG._tvg_picture_get_size(picture, sizePtr, sizePtr + 4);
                const sizeView = new Float32Array(TVG.HEAPF32.buffer, sizePtr, 2);
                const origWidth = sizeView[0];
                const origHeight = sizeView[1];
                TVG._free(sizePtr);

                const maxWidth = 600;
                const maxHeight = 500;
                const scale = Math.min(maxWidth / origWidth, maxHeight / origHeight);
                const newWidth = origWidth * scale;
                const newHeight = origHeight * scale;

                TVG._tvg_picture_set_size(picture, newWidth, newHeight);
                TVG._tvg_paint_translate(picture, 100, 50);
                TVG._tvg_canvas_push(canvasPtr, picture);

                log(`Loaded ${file.name}: ${origWidth}x${origHeight} → ${newWidth.toFixed(0)}x${newHeight.toFixed(0)}`);

                // Render
                TVG._tvg_canvas_draw(canvasPtr, 1);
                TVG._tvg_canvas_sync(canvasPtr);

                // For SW backend, copy buffer to canvas
                const backend = document.getElementById('backend').value;
                if (backend === 'sw') {
                    const buffer = engine.render();
                    const size = engine.size();
                    const canvas = document.getElementById('canvas');
                    const ctx = canvas.getContext('2d');
                    const imageData = new ImageData(
                        new Uint8ClampedArray(buffer),
                        size.width,
                        size.height
                    );
                    ctx.putImageData(imageData, 0, 0);
                }

                log('File loaded and rendered successfully!');
            } else {
                log(`ERROR: Failed to load ${file.name} (error code: ${result})`);
                TVG._tvg_paint_rel(picture);
            }
        };

        window.clearCanvas = function() {
            if (!engine) {
                log('ERROR: Engine not initialized!');
                return;
            }

            engine.clear();
            TVG._tvg_canvas_draw(canvasPtr, 1);
            TVG._tvg_canvas_sync(canvasPtr);

            const backend = document.getElementById('backend').value;
            if (backend === 'sw') {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            log('Canvas cleared!');
        };

        applyRendererFromQuery();
        setupRendererChangeHandler();
        loadModule();
    </script>
</body>
</html>
